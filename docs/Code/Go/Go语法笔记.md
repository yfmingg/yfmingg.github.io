# Go语法笔记

## 数据类型

Go 有四类数据类型：

基本类型：数字、字符串和布尔值，默认值传递
聚合类型：数组和结构，默认值传递
引用类型：指针、切片、映射、函数和通道，默认引用传递
接口类型：接口，默认引用传递

rune 只是 int32 数据类型的别名。 它用于表示 Unicode 字符（或 Unicode 码位）。 例如，假设有以下代码：

```
rune := 'G'
fmt.Println(rune)
```

在 Go 中，不能将布尔类型隐式转换为 0 或 1。 你必须显式执行此操作。

## 函数
Go 里面有三种类型的函数：

- 普通的带有名字的函数
- 匿名函数或者lambda函数
- 方法（Methods

除了 main()、init() 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为函数签名。

函数重载 (function overloading) 指的是可以编写多个同名函数，只要它们拥有不同的形参/或者不同的返回值，在 Go 里面函数重载是不被允许的。这将导致一个编译错误，Go 语言不支持这项特性的主要原因是函数重载需要进行多余的类型匹配影响性能；没有重载意味着只是一个简单的函数调度。所以你需要给不同的函数使用不同的名字，我们通常会根据函数的特征对函数进行命名

目前 Go 没有泛型 (generic) 的概念，也就是说它不支持那种支持多种类型的函数。不过在大部分情况下可以通过接口 (interface)，特别是空接口与类型选择（type switch，参考 第 11.12 节）与/或者通过使用反射（reflection，参考 第 6.8 节）来实现相似的功能。使用这些技术将导致代码更为复杂、性能更为低下，所以在非常注意性能的的场合，最好是为每一个类型单独创建一个函数，而且代码可读性更强。

如果需要申明一个在外部定义的函数，你只需要给出函数名与函数签名，不需要给出函数体：func flushICache(begin, end uintptr) // implemented externally

函数也可以以申明的方式被使用，作为一个函数类型，就像：type binOp func(int, int) int   在这里，不需要函数体 {}。

匿名函数同样被称之为闭包（函数式语言的术语）：它们被允许调用定义在其它环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。另一种表示方式为：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁

## 数组和slice

Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），所以可以通过 new() 来创建： var arr1 = new([5]int)。

那么这种方式和 var arr2 [5]int 的区别是什么呢？arr1 的类型是 *[5]int，而 arr2 的类型是 [5]int。

这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。例如：

arr2 := *arr1
arr2[2] = 100
这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。

所以在函数中数组作为参数传入时，如 func1(arr2)，会产生一次数组拷贝，func1() 方法不会修改原始的数组 arr2。

如果你想修改原数组，那么 arr2 必须通过 & 操作符以引用方式传过来，例如 func1(&arr2)

如果 s2 是一个切片，你可以将 s2 向后移动一位 s2 = s2[1:]，但是末尾没有移动。切片只能向后移动，s2 = s2[-1:] 会导致编译错误。切片不能被重新分片以获取数组的前一个元素。

注意 绝对不要用指针指向切片。切片本身已经是一个引用类型，所以它本身就是一个指针！！

## map

不要使用 new()，永远用 make() 来构造 map，注意 如果你错误地使用 new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：

## new() 和 make() 的区别
看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。

new(T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 *T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &T{}。
make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel

换言之，new() 函数分配内存，make() 函数初始化；

[](./img/7.2_fig7.3.png)

在图 7.3 的第一幅图中：

var p *[]int = new([]int) // *p == nil; with len and cap 0
p := new([]int)
在第二幅图中， p := make([]int, 0) ，切片 已经被初始化，但是指向一个空的数组。

以上两种方式实用性都不高。下面的方法：

var v []int = make([]int, 10, 50)
或者

v := make([]int, 10, 50)
这样分配一个有 50 个 int 值的数组，并且创建了一个长度为 10，容量为 50 的切片 v，该切片指向数组的前 10 个元素。

## 指针

在 Go 中，有两个运算符可用于处理指针：

& 运算符使用其后对象的地址。
\* 运算符取消引用指针。 你可以前往指针中包含的地址访问其中的对象。

```Go
package main

import "fmt"

func main() {
    firstName := "John"
    updateName(&firstName)
    fmt.Println(firstName)
}

func updateName(name *string) {
    *name = "David"
}
```

## fallthrough 关键字

默认情况下，Go 在进入 case 语句后就会运行它，然后退出 switch 子句。 若要跳转到下一个 case 子句，请使用 fallthrough 关键字。 可以从 case 子句调用函数，并且可以在一个 case 子句中将多个表达式分组。

## defer、panic 和 recover 函数

## goroutines、channel、select

Go 中的 channel 是 goroutine 之间的通信机制。 请记住 Go 的并发方法是：“不是通过共享内存通信；而是通过通信共享内存。”当你需要将值从一个 goroutine 发送到另一个时，可以使用通道。 

并发，不同分支程序同时执行，同步，让同时执行的不同程序按既定流程运行，即不同程序要实现同步

# 测试程序