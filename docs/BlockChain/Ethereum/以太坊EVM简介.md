# 以太坊EVM简介

## 什么是EVM？

EVM 是以太坊的一部分，负责智能合约的部署和执行。实际上，从一个 EOA到另一个 EOA 的简单价值转移交易不需要涉及它，但其他所有交易都将涉及到由 EVM 计算的状态更新。从高级别来看，EVM 嵌在每个以太坊节点中，运行在以太坊区块链上的 EVM 可以被认为是一台包含数百万个可执行对象的全球分散式计算机，每个对象都具备自身的永久数据存储。

EVM 是一个类似图灵完备状态机，“类似”是因为被任何给定智能合约的gas 可用量限定了，因此所有执行过程都被限制在有限数量的计算步骤内。因此，中断问题是“解决的”（所有进程都将停止），并且避免了执行程序可能（意外或者恶意）永久运行，从而使以太坊平台完全停止的情况。

EVM 有基于堆栈的体系结构，并将所有的内存值存储在堆栈上。它的字节大小是 256 位（主要是为了方便本地散列和椭圆曲线操作），并具有几个可寻址的数据组件：

1. 一种不可改变的程序代码 ROM，与要执行的智能合约的字节码一起加载。
2. 易失存储器(内存)，每个位置都显式初始化为零。
3. 作为以太坊状态的一部分的永久存储器，其值也被初始化为零。
4. 还有一组在执行期间可用的环境变量和数据。

与现存技术的比较：

术语“虚拟机”通常应用于实际计算机的虚拟化，通常由“管理程序”如VirtualBox 或 QEMU，或整个操作系统实例如 Linux 的 KVM 实现。它们必须分别提供实际硬件，系统调用和其它内核功能的软件抽象。

EVM 在一个更有限的领域中运行： 它只是一个计算引擎，因此提供了一个抽象的计算和存储，类似于 Java 虚拟机（JVM）规范。从高级别角度来看，JVM旨在提供一个与底层主机操作系统或者硬件无关的运行环境，从而实现各种跨系统的兼容性。高级编程语言如 Java 或 Scala（使用 JVM）或 C#（使用.NET）被编译成它们各自虚拟机的字节码指令集。以同样的方式，EVM 执行自己的字节码指令集（在下一节中描述），这些指令集被编译成更高级的智能合约编程语言，如Solidity。

因此，EVM 没有调度能力，因为执行顺序是外部组织的，以太坊客户端通过运行经过验证的区块交易来确定哪些智能合约需要执行或者按照什么顺序执行。从这点上来说，以太坊世界中的计算机是单线程的，就像 JavaScript 一样。EVM也没有任何“系统接口”处理或者“硬件支持”——没有实际的机器可以与之相接。以太坊世界的计算机是完全虚拟的。

## 什么是 EVM 操作码？

EVM 操作码（指令集）提供了您可能期望的大多数操作，包括：

1. 算术和位逻辑运算
2. 执行内容查询
3. 堆栈、内存和存储访问
4. 控制流操作
5. 日志记录、调用和其他算子

所有以太坊字节码都可以分解为一系列操作数和操作码。操作码是一些预定义的操作指令，EVM 识别后能够执行这个操作。例如，ADD 操作码在 EVM 字节码中表示为 0x01。它从栈中删除两个元素并把结果压入栈中。

从堆栈中移除和压入堆栈的元素数量取决于操作码。例如，PUSH 操作码有 32 个：PUSH1 到 PUSH32。 PUSH 在栈上 添加一个 字节元素，元素的大小可以从 0 到 32 字节。它不会从栈中删除元素。作为对比, 操作码 ADDMOD 表示 模加法运算 ，它从栈中删除3个元素然后压入模加结果。请注意，PUSH 操作码是唯一带有操作数的操作码。

每个操作码都占一个字节，并且操作成本有大有小。操作码的操作成本是固定的或由公式算出来。例如，ADD 操作码固定需要3 gas。而将数据保存在存储中的操作码 SSTORE ，当把值从0设置为非0时消耗 20,000 gas，当把值改为0或保持为0不变时消耗 5000 gas。详细参考：<https://ethereum.org/zh/developers/docs/evm/opcodes>

当你调用一个智能合约时，EVM会运行并执行其字节码中的一组指令（操作码）。其中一些操作码指示EVM从/向不同的位置读写数据。EVM需要这些多个数据位置来正确完成其工作。

## 以太坊状态

EVM 的作用是根据以太坊协议定义，通过计算智能合约代码执行后的有效状态转换来更新以太坊状态。这一层面导致了以太坊作为基于交易的状态机的描述，反映了外部参与者（即账户拥有者和矿工）通过创建、接受和发送交易来启动转换状态的事实。在这一点上，考虑什么构成以太坊状态是有用的。

在最高级别中，我们有以太坊世界状态。世界状态是以太坊地址（160 位值）到账户的映射。在较低的级别，每个以太坊地址代表一个包含以太余额的账户（存储为账户拥有的 Wei 数量）、nonce（如果这是 EOA，就代表从该账户成功发送的交易数量，如果这是合约账户，就代表被创建的合约数量）、该账户的存储（如果是一个永久性的数据存储，仅供智能合约使用），以及该账户的程序代码（同样地，仅当账户是智能合约账户时）。EOA 将始终没有代码和空存储。

当一笔交易导致智能合约代码执行时，EVM 将实例化，其中包含与正在创建的当前块和正在处理的特定交易相关的所有必需信息。尤其是，EVM 的程序代码 ROM 与正在被调用的合约账户的代码一起加载，程序计数器被设定为零，存储从合约账户的存储中加载，内存设置为全零，所有区块和环境变量都被设置。一个关键变量是执行此操作所需的 gas 供应量，它被设置为交易开始时发送方支付的 gas 量。

随着代码的执行，根据被执行的运算的 gas 量，gas 供应量减少。如果在任意时刻，Gas 供给量减少到零，我们会得到“gas 不足”的异常；此时执行过程立刻停止而且交易被废弃。不应用到对以太坊状态的任何更改，并且其以太坊余额下降以向区块受益人支付用于执行代码到停止点的资源。此时，您可以认为 EVM运行在以太坊世界的沙盒副本上，如由于任何原因无法完成执行，则系统完全放弃此沙盒副本。但是，如果成功的执行完成，那么系统将更新实际状态以匹配沙盒版本，包括被调用的合约数据的各种更改、任何被创建的新合约以及任何被发起的以太坊余额传输。

需要注意的是，由于智能合约本身可以有效的启动交易，代码的执行是一个递归的处理过程。一个合约可以调用其他合约，每次调用都会导致围绕调用的新目标实例化另一个 EVM。每个实例都有其沙盒世界状态，从上级 EVM 的沙盒来启动新的执行过程。每一个实例也被赋予一个特定的 gas 供应量（当然，不超过上级的 gas 剩余量），因此，当由于 gas 太少而无法完成其执行时，可能会自行停止。同样地，在这种情况下，沙盒状态被丢弃，执行过程回到上级 EVM。

## 合约部署代码

在以太坊平台上创建和部署新合约时使用的代码与合约本身的代码之间存在重要但是微妙的差异。为了创建一个新的合约，我们需要一个特殊的交易，并将to 字段设置成为 0x0 的特殊地址，将data 字段设置合约的初始代码。处理此类合约创建的交易时，新合约账户的代码不是交易数据字段中的代码。相反，当像这样的交易被执行时，用交易的 data 字段的代码来实例化 EVM，然后将执行该部署代码的输出作为新合约账户的代码。因此。新合约可以在部署时使用以太坊世界状态以编程方式初始化，在合约的存储中设置值，甚至发送以太坊或者创建更多的新合约。

部署字节码用于新合约账户初始化的各个方面，包括当新交易调用此合约（即运行时的字节码）时将实际执行的字节码，以及基于合约的构造函数初始化所有内容的代码。另一方面，运行时字节码恰恰是在调用新合约时被执行的字节码，而不包括在合约部署期间初始化合约所需的字节码。即运行时字节码是部署字节码的一个子集。换句话说，运行时字节码完全包含在部署字节码中。

## 图灵完备和 gas

当然你可以直接read the fucking code，代码位于core/vm/gas.go和core/vm/gas_table.go中。

## 解释器执行

输入一笔交易，内部会转换成一个Message对象，传入EVM执行。如果是一笔普通转账交易，那么直接修改StateDB中对应的账户余额即可。如果是智能合约的创建或者调用，则通过EVM中的解释器加载和执行字节码，执行过程中可能会查询或者修改StateDB。另外EVM会根据Message生成一个Contract对象以便后续执行，Contract中会根据合约地址，从StateDB中加载对应的代码，后面就可以送入解释器执行了。另外，执行合约能够消耗的油费有一个上限，就是节点配置的每个区块能够容纳的GasLimit。

EVM是基于栈的虚拟机，解释器中需要操作四大组件：

- PC：类似于CPU中的PC寄存器，指向当前执行的指令
- Stack：执行堆栈，位宽为256 bits，最大深度为1024
- Memory：内存空间
- Gas：油费池，耗光邮费则交易执行失败

具体解释执行的流程参见下图

![evm](img/evm1.jpg)

EVM的每条指令称为一个OpCode，占用一个字节，所以指令集最多不超过256，具体描述参见：<https://ethervm.io> 。比如下面就是一个示例（PUSH1=0x60, MSTORE=0x52）：

PUSH1 0x80 PUSH1 0x40 MSTORE  ==> 60 80 60 40 52

首先PC会从合约代码中读取一个OpCode，然后从一个JumpTable中检索出对应的operation，也就是与其相关联的函数集合。接下来会计算该操作需要消耗的油费，如果油费耗光则执行失败，返回ErrOutOfGas错误。如果油费充足，则调用execute()执行该指令，根据指令类型的不同，会分别对Stack、Memory或者StateDB进行读写操作。

## 创建合约

如果某一笔交易的to地址为nil，则表明该交易是用于创建智能合约的。

首先需要创建合约地址，采用下面的计算公式：Keccak(RLP(call_addr, nonce))[:12]。也就是说，对交易发起人的地址和nonce进行RLP编码，再算出Keccak哈希值，取后20个字节作为该合约的地址。

下一步就是根据合约地址创建对应的stateObject，然后存储交易中包含的合约代码。该合约的所有状态变化会存储在一个storage trie中，最终以Key-Value的形式存储到StateDB中。代码一经存储则无法改变，而storage trie中的内容则是可以通过调用合约进行修改的，比如通过SSTORE指令。

![evm5](img/evm5.jpg)

## 调用合约函数

前面分析完了EVM解释执行的主要流程，可能有些同学会问：那么EVM怎么知道交易想调用的是合约里的哪个函数呢？别急，前面提到跟合约代码一起送到解释器里的还有一个Input，而这个Input数据是由交易提供的。

![evm2](img/evm2.jpg)

Input数据通常分为两个部分：

- 前面4个字节被称为“4-byte signature”，是某个函数签名的Keccak哈希值的前4个字节，作为该函数的唯一标识。（可以在该网站查询目前所有的函数签名<https://www.4byte.directory/>）
- 后面跟的就是调用该函数需要提供的参数了，长度不定。举个例子：我在部署完A合约后，调用add(1)对应的Input数据是: 0x87db03b70000000000000000000000000000000000000000000000000000000000000001

而在我们编译智能合约的时候，编译器会自动在生成的字节码的最前面增加一段函数选择逻辑：首先通过CALLDATALOAD指令将“4-byte signature”压入堆栈中，然后依次跟该合约中包含的函数进行比对，如果匹配则调用JUMPI指令跳入该段代码继续执行。

这里提到了CALLDATALOAD，就顺便讲一下数据加载相关的指令，一共有4种：

- CALLDATALOAD：把输入数据加载到Stack中
- CALLDATACOPY：把输入数据加载到Memory中
- CODECOPY：把当前合约代码拷贝到Memory中
- EXTCODECOPY：把外部合约代码拷贝到Memory中

最后一个EXTCODECOPY不太常用，一般是为了审计第三方合约的字节码是否符合规范，消耗的gas一般也比较多。这些指令对应的操作如下图所示：

![evm2](img/evm3.jpg)

## 合约调用合约：CALL

在中大型的项目中，我们不可能在一个智能合约中实现所有的功能，而且这样也不利于分工合作。一般情况下，我们会把代码按功能划分到不同的库或者合约中，然后提供接口互相调用。

在Solidity中，如果只是为了代码复用，我们会把公共代码抽出来，部署到一个library中，后面就可以像调用C库、Java库一样使用了。但是library中不允许定义任何storage类型的变量，这就意味着library不能修改合约的状态。如果需要修改合约状态，我们需要部署一个新的合约，这就涉及到合约调用合约的情况。

合约内部调用另外一个合约，有4种调用方式：

- CALL
- CALLCODE
- DELEGATECALL
- STATICALL

这里先以最简单的CALL为例，调用流程如下图所示：

![evm4](img/evm4.jpg)

可以看到，调用者把调用参数存储在内存中，然后执行CALL指令。

CALL指令执行时会创建新的Contract对象，并以内存中的调用参数作为其Input。

解释器会为新合约的执行创建新的Stack和Memory，从而不会破环原合约的执行环境。

新合约执行完成后，通过RETURN指令把执行结果写入之前指定的内存地址，然后原合约继续向后执行。

## 合约调用合约：CALL vs. CALLCODE

CALL和CALLCODE的区别在于：代码执行的上下文环境不同。

具体来说，CALL修改的是被调用者的storage，而CALLCODE修改的是调用者的storage。

![evm6](img/evm6.jpg)

我们写个合约验证一下我们的理解：

```solidity
pragma solidity ^0.4.25;

contract A {
  int public x;

  function inc_call(address _contractAddress) public {
      _contractAddress.call(bytes4(keccak256("inc()")));
  }
  function inc_callcode(address _contractAddress) public {
      _contractAddress.callcode(bytes4(keccak256("inc()")));
  }
}

contract B {
  int public x;

  function inc() public {
      x++;
  }
}
```

我们先调用一下inc_call()，然后查询合约A和B中x的值有什么变化: 可以发现，合约B中的x被修改了，而合约A中的x还等于0。

我们再调用一下inc_callcode()试试：可以发现，这次修改的是合约A中x，合约B中的x保持不变。

## 合约调用合约：CALLCODE vs. DELEGATECALL

实际上，可以认为DELEGATECALL是CALLCODE的一个bugfix版本，官方已经不建议使用CALLCODE了。

CALLCODE和DELEGATECALL的区别在于：msg.sender不同。

具体来说，DELEGATECALL会一直使用原始调用者的地址，而CALLCODE不会。

![evm7](img/evm7.jpg)

我们还是写一段代码来验证我们的理解：

```solidity
pragma solidity ^0.4.25;

contract A {
  int public x;

  function inc_callcode(address _contractAddress) public {
      _contractAddress.callcode(bytes4(keccak256("inc()")));
  }
  function inc_delegatecall(address _contractAddress) public {
      _contractAddress.delegatecall(bytes4(keccak256("inc()")));
  }
}

contract B {
  int public x;

  event senderAddr(address);
  function inc() public {
      x++;
      emit senderAddr(msg.sender);
  }
}
```

我们首先调用一下inc_callcode()，观察一下log输出：可以发现，msg.sender指向合约A的地址，而非交易发起者的地址。

我们再调用一下inc_delegatecall()，观察一下log输出：可以发现，msg.sender指向的是交易的发起者。

## 合约调用合约：STATICCALL

STATICCALL放在这里似乎有滥竽充数之嫌，因为目前Solidity中并没有一个low level API可以直接调用它，仅仅是计划将来在编译器层面把调用view和pure类型的函数编译成STATICCALL指令。

view类型的函数表明其不能修改状态变量，而pure类型的函数则更加严格，连读取状态变量都不允许。

目前是在编译阶段来检查这一点的，如果不符合规定则会出现编译错误。如果将来换成STATICCALL指令，就可以完全在运行时阶段来保证这一点了，你可能会看到一个执行失败的交易。
